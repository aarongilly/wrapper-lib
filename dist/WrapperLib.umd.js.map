{"version":3,"file":"WrapperLib.umd.js","sources":["../src/wrapper.ts","../src/main.ts"],"sourcesContent":["/**\r\n * Options that Wrappers can be initialized with.\r\n */\r\nexport interface WrapperOptions {\r\n    id?: string;\r\n    name?: string;\r\n    value?: string;\r\n    text?: string;\r\n    html?: string;\r\n    style?: string;\r\n    bind?: WrapperObservableListMember;\r\n}\r\n\r\nexport interface WrapperObservableListMember {\r\n    bindFeature: ObservableFeature;\r\n    toFeature: ObservableFeature;\r\n    ofWrapper: Wrapper;\r\n    xferFunc?: Function;\r\n}\r\n\r\nexport interface WrapperlessObservableListMember {\r\n    xferFunc: Function;\r\n    sub: WrapperlessObserver;\r\n}\r\n\r\nexport interface WrapperlessObserver {\r\n    handleChange: Function;\r\n}\r\n\r\nexport interface WrappedInputLabelPairOptions {\r\n    lbl?: string,\r\n    default?: string,\r\n    placehold?: string,\r\n    inputType?: \"button\" | \"checkbox\" | \"color\" | \"date\" | \"datetime-local\" | \"email\" | \"file\" | \"hidden\" | \"image\" | \"month\" | \"number\" | \"password\" | \"radio\" | \"range\" | \"reset\" | \"search\" | \"submit\" | \"tel\" | \"text\" | \"time\" | \"url\" | \"week\",\r\n    contStyle?: string,\r\n    lblStyle?: string,\r\n    inputStyle?: string,\r\n    stacked?: boolean\r\n}\r\n\r\nexport type ObservableFeature = \"text\" | \"value\" | \"style\"\r\nexport type WrapperPosition = \"inside\" | \"before\" | \"after\"\r\n\r\ntype HTMLElementsWithValue = HTMLButtonElement | HTMLInputElement | HTMLMeterElement | HTMLLIElement | HTMLOptionElement | HTMLProgressElement | HTMLParamElement;\r\n\r\nexport class Wrapper {\r\n    public element: HTMLElement;\r\n    public subscribers: WrapperObservableListMember[];\r\n    constructor(tag?: keyof HTMLElementTagNameMap, existingElement?: HTMLElement, intializers?: WrapperOptions) {\r\n        this.subscribers = [];\r\n        if (existingElement) {\r\n            this.element = existingElement;\r\n        } else {\r\n            this.element = document.createElement(tag!)\r\n        }\r\n        //auto-call notify subscribers if inputs change\r\n        if (this.element.tagName === \"INPUT\") this.onEvent('input', this.notifySubscribers.bind(this));\r\n        if (this.element.tagName === \"SELECT\") this.onEvent('change', this.notifySubscribers.bind(this));\r\n        if (this.element.tagName === \"TEXTAREA\") this.onEvent('input', this.notifySubscribers.bind(this));\r\n        if (intializers) {\r\n            if (intializers.id) this.element.id = intializers.id!;\r\n            if (intializers.name) this.element.setAttribute('name', intializers.name!);\r\n            if (intializers.value) {\r\n                if (this.element.hasOwnProperty('value')) {\r\n                    (<HTMLElementsWithValue>this.element).value = intializers.value!;\r\n                } else {\r\n                    throw new Error(\"attempted to set value on a tag that doesn't support that\")\r\n                }\r\n            }\r\n            if (intializers.text != undefined) this.element.innerText = intializers.text!;\r\n            if (intializers.html != undefined) this.element.innerHTML = intializers.html!;\r\n            if (intializers.style) this.element.setAttribute('style', intializers.style!);\r\n            if (intializers.bind) {\r\n                let sub: WrapperObservableListMember = {\r\n                    bindFeature: intializers.bind.bindFeature,\r\n                    toFeature: intializers.bind.toFeature,\r\n                    ofWrapper: this,\r\n                    xferFunc: intializers.bind.xferFunc\r\n                }\r\n                intializers.bind.ofWrapper.addSubscriber(sub);//this feels wrong\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Wraps an existing HTML Element with a Wrapper\r\n     * @param element the element to wrap\r\n     * @returns the new wrapper, for chaining\r\n     */\r\n    static wrap(element: HTMLElement, initializers?: WrapperOptions): Wrapper {\r\n        return new Wrapper((<keyof HTMLElementTagNameMap>element.tagName), element, initializers);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Wrapper instance inside, before, or after the one it was called against.\r\n     * Returns the newly created wrapper.\r\n     * @param tag tag of the HTML Element to create\r\n     * @param initializers an object with optional keys to initialize the element with\r\n     * @param locaitn inside appendChild(), before before(), after after()\r\n     * @returns the new wrapper, for chaining\r\n     */\r\n    newWrap(tag: keyof HTMLElementTagNameMap, initializers?: WrapperOptions, location: WrapperPosition = 'inside'): Wrapper {\r\n        let nW = new Wrapper(tag, undefined, initializers);\r\n        if (location === 'inside') this.element.appendChild(nW.element);\r\n        if (location === 'after') this.element.after(nW.element);\r\n        if (location === 'before') this.element.before(nW.element);\r\n        return nW;\r\n    }\r\n\r\n    /**\r\n     * Binds the Wrapper to a WrapperlessObservable instance. If you want to bind between\r\n     * wrappers, use the bindToWrapper method.\r\n     * @param target observerable to bind to\r\n     * @param boundFeature feature on this Wrapper to change, not used if xferFunc is supplied\r\n     * @param xferFunc optional, what to do with the new value, overrides boundFeature\r\n     */\r\n    bindTo(target: WrapperlessObservable, boundFeature?: ObservableFeature, xferFunc?: Function) {\r\n        if (xferFunc != undefined) {\r\n            target.addSubscriber(this, xferFunc);\r\n        } else {\r\n            if (boundFeature == undefined) throw new Error(\"No bound feature or xferFunc included.\");\r\n            if (boundFeature == 'text') target.addSubscriber(this, (nv: string) => this.text(nv));\r\n            if (boundFeature == 'value') target.addSubscriber(this, (nv: string) => this.setVal(nv));\r\n            if (boundFeature == 'style') target.addSubscriber(this, (nv: string) => this.style(nv));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Bind this wrapper's text/style/value to the text/style/value of the targetWrapper\r\n     * @param targetWrapper Wrapper to bind to\r\n     * @param targetFeature The feature you care about on the Wrapper you're subscribing \r\n     * @param thisFeature Which part of this Wrapper should be updated\r\n     * @param using optional transfer function, default: text for non-inputs, otherwise value\r\n     * @returns this, for chaining\r\n     */\r\n    bindToWrapper(targetWrapper: Wrapper, targetFeature: ObservableFeature, thisFeature: ObservableFeature, using?: Function): Wrapper {\r\n        let sub: WrapperObservableListMember = {\r\n            bindFeature: targetFeature,\r\n            toFeature: thisFeature,\r\n            ofWrapper: this,\r\n            xferFunc: using\r\n        }\r\n        targetWrapper.addSubscriber(sub);\r\n        //initilize bound value to whatever it is now\r\n        let currentVal = targetWrapper.getText();\r\n        if (sub.bindFeature === 'style' && targetWrapper.getStyle() != null) currentVal = targetWrapper.getStyle()!;\r\n        if (sub.bindFeature === 'value') currentVal = targetWrapper.getVal().toString();\r\n        this.handleChange(currentVal, sub)\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Propogate out a request to handle change to every entry in the subscriber list\r\n     * @returns this, for chaining\r\n     */\r\n    notifySubscribers(): Wrapper {\r\n        // console.warn\r\n        this.subscribers.forEach(sub => {\r\n            let newVal = this.getText();\r\n            if (sub.bindFeature == 'value') newVal = this.getVal().toString();\r\n            if (sub.bindFeature == 'style') newVal = this.getStyle()!;\r\n            sub.ofWrapper.handleChange(newVal, sub)\r\n        })\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates this wrapper with the new value from the WrapperObservable that called it,\r\n     * in accordance with the terms of the subscription.\r\n     * @param newValue the new value from the thing\r\n     * @param subscription the subscription itself, or the function to run\r\n     */\r\n    handleChange(newValue: string, subscription: WrapperObservableListMember | Function): void {\r\n        if (typeof subscription === 'function') {\r\n            subscription(newValue);\r\n        } else {\r\n            if (subscription.xferFunc) {\r\n                subscription.xferFunc(newValue);\r\n            } else {\r\n                if (subscription.toFeature === 'text') this.text(newValue);\r\n                if (subscription.toFeature === 'style') this.style(newValue);\r\n                if (subscription.toFeature === 'value') this.setVal(newValue);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a new subscriber, which contains a subscribing wrapper and\r\n     * details about how it should be updated on changes to this.\r\n     * @param newSub subscribing wrapper to add\r\n     * @returns this, for chaining\r\n     */\r\n    addSubscriber(newSub: WrapperObservableListMember): Wrapper {\r\n        this.subscribers.push(newSub);\r\n        return this;\r\n    }\r\n\r\n    //removeSubscriber //todo - this\r\n    removeSubscriber(subbedWrapper: Wrapper): Wrapper {\r\n        this.subscribers = this.subscribers.filter(sub => sub.ofWrapper != subbedWrapper)\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes all subscribers from the list.\r\n     * @returns this, for chaining\r\n     */\r\n    purgeSubscribers() {\r\n        this.subscribers = [];\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Sets the innerText of the wrapped element.\r\n     * @param text the text to set\r\n     * @returns this, for chaining\r\n     */\r\n    text(text: string): Wrapper {\r\n        this.element.innerText = text;\r\n        this.subscribers.forEach(sub => { if (sub.bindFeature == 'text') sub.ofWrapper.handleChange(text, sub) });\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Chainable horthand for this.element.setAttribute(attribute, value)\r\n     * @param attribute attribute to set\r\n     * @param value value to set it to\r\n     * @returns this, for chaining\r\n     */\r\n    attr(attribute: string, value: string): Wrapper {\r\n        this.element.setAttribute(attribute, value)\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the innerHTML of the wrapped element.\r\n     * @param html the text to set\r\n     * @returns this, for chaining\r\n     */\r\n    html(html: string): Wrapper {\r\n        this.element.innerHTML = html;\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Sets the `style` attribute of the wrapped element\r\n     * @param styleString string literal for css styles\r\n     * @param append true = append to the existing styles; false =  replace it\r\n     * @returns this, for chaining\r\n     */\r\n    style(styleString: string, append?: boolean): Wrapper {\r\n        let style = \"\";\r\n        if (append && this.element.getAttribute('style') != null) {\r\n            style = this.element.getAttribute('style')!.trim();\r\n            if (style.charAt(style.length - 1) != \";\") style = style + \"; \"\r\n        }\r\n        this.element.setAttribute('style', style + styleString);\r\n        this.subscribers.forEach(sub => { if (sub.bindFeature === 'style') sub.ofWrapper.handleChange(styleString, sub) });\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Sets the name of the wrapped element.\r\n     * @param name the text to set\r\n     * @returns this, for chaining\r\n     */\r\n    name(name: string): Wrapper {\r\n        this.element.setAttribute('name', name);\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Sets the placeholder of the wrapped element.\r\n     * @param placeholder the text to set\r\n     * @returns this, for chaining\r\n     */\r\n    placehold(placeholder: string): Wrapper {\r\n        this.element.setAttribute('placeholder', placeholder);\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Returns the value of a given attribute on the wrapped element\r\n     * @returns the value of attribute on the element, or null if no attribute exists\r\n     */\r\n    getAttr(attribute: string): string | null {\r\n        return this.element.getAttribute(attribute);\r\n    }\r\n\r\n    /**\r\n     * Simple alias for {@link attr}.\r\n     * @param attribute attribute name to set\r\n     * @param value the value to set\r\n     * @returns this, for chaining\r\n     */\r\n    setAttr(attribute: string, value: string): Wrapper {\r\n        return this.attr(attribute, value);\r\n    }\r\n\r\n    /**\r\n     * Returns the style string of a given attribute on the wrapped element\r\n     * @returns the style string of attribute on the element, or null if no attribute exists\r\n     */\r\n    getStyle(): string | null {\r\n        return this.element.getAttribute('style');\r\n    }\r\n\r\n    /**\r\n     * Simple alias for {@link style}.\r\n     * @param styleString the value to set\r\n     * @returns this, for chaining\r\n     */\r\n    setStyle(styleString: string): Wrapper {\r\n        return this.style(styleString);\r\n    }\r\n\r\n    /**\r\n     * Returns the innerText of the wrapped element\r\n     * @returns the innerText of the wrapped element\r\n     */\r\n    getText(): string {\r\n        return this.element.innerText;\r\n    }\r\n\r\n    /**\r\n     * Simple alias for {@link text}.\r\n     * @param text string to set\r\n     * @returns this, for chaining\r\n     */\r\n    setText(text: string): Wrapper {\r\n        return this.text(text);\r\n    }\r\n\r\n\r\n    /**\r\n     * Gets the value of Wrapped things like inputs, textareas\r\n     * @returns the value of the wrapped element\r\n     */\r\n    getVal() {\r\n        if (this.element.tagName == 'INPUT' && this.getAttr('type') == \"checkbox\") return (<HTMLInputElement>this.element).checked;\r\n        return (<HTMLInputElement>this.element).value //inline type assertion IS possible\r\n    }\r\n\r\n    /**\r\n     * Sets the value of Wrapped things like inputs, textareas\r\n     * @returns this, for chaining\r\n     */\r\n    setVal(val: string) {\r\n        (<HTMLInputElement | HTMLParamElement | HTMLButtonElement |\r\n            HTMLOptionElement | HTMLLIElement>this.element).value = val;\r\n        this.subscribers.forEach(sub => { if (sub.bindFeature === \"value\") sub.ofWrapper.handleChange(val, sub) });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Grabs data stored in an element's dataset. The 'data-' part\r\n     * of the dataset is not necessary to include.\r\n     * @param key the data- set element name\r\n     * @returns the value of the keyed data\r\n     */\r\n    getData(key: string) {\r\n        return this.element.dataset[key];\r\n    }\r\n\r\n    /**\r\n     * Sets data stored in an element's dataset. The 'data-' part\r\n     * of the dataset is not necessary to include.\r\n     * @param key the data- set element name\r\n     * @param val the string to be stored\r\n     * @returns this, for chaining\r\n     */\r\n    setData(key: string, val: string) {\r\n        this.element.setAttribute('data-' + key, val);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new event listener of the given type on the Wrapped element\r\n     * @param eventType type of event to bind the function to\r\n     * @param fun the function to run when the event occurs\r\n     * @returns this, for chaining\r\n     */\r\n    onEvent(eventType: keyof HTMLElementEventMap, fun: Function): Wrapper {\r\n        this.element.addEventListener(eventType, (e) => fun(e));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new click event listener on the wrapped element\r\n     * @param fun the function to run on click;\r\n     * @returns this, for chaining\r\n     */\r\n    onClick(fun: Function): Wrapper {\r\n        this.onEvent('click', fun);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n    * Creates a new input event listener on the wrapped element\r\n    * @param fun the function to run on input;\r\n    * @returns this, for chaining\r\n    */\r\n    onInput(fun: Function): Wrapper {\r\n        this.onEvent('input', fun);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new change event listener on the wrapped element\r\n     * @param fun the function to run on changes;\r\n     * @returns this, for chaining\r\n     */\r\n    onChange(fun: Function): Wrapper {\r\n        this.onEvent('change', fun);\r\n        return this;\r\n    }\r\n\r\n    ///#region #### Composite Wrappers ####\r\n\r\n    /**\r\n     * For use with <ol> or <ul> elements\r\n     * Creates a series of <li> elements for elements in an array\r\n     * @param textList the visible text to create each element for\r\n     * @param idList optional IDs to include\r\n     * @returns this, for chaining\r\n     */\r\n    listContent(textList: string[], idList?: string[]) {\r\n        if (this.element.tagName != 'UL' && this.element.tagName != 'OL') {\r\n            console.error({ 'Not a list container->:': this.element });\r\n            throw new Error('List Content must be appended to a \"ul\" or \"ol\"');\r\n        }\r\n        if (idList) {\r\n            if (textList.length != idList.length) {\r\n                console.error({ 'not the same length': textList, 'as': idList });\r\n                throw new Error('textList and idList not the same length');\r\n            }\r\n            textList.forEach((text, ind) => {\r\n                this.newWrap('li', { 'id': idList[ind] }).text(text);\r\n            })\r\n        } else {\r\n            textList.forEach((text) => {\r\n                this.newWrap('li').text(text);\r\n            })\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * For use with <select> elements\r\n     * Creates a list of <option> elements inside the <select>\r\n     * with the given display text and value text\r\n     * @param textList \r\n     * @param valList \r\n     * @param idList \r\n     * @returns this, for chaining\r\n     */\r\n    selectContent(textList: string[], valList?: string[], idList?: string[]) {\r\n        if (!valList) valList = textList;\r\n        if (textList.length != valList.length) {\r\n            console.error({ 'not the same length': textList, 'as': valList });\r\n            throw new Error('textList and idList not the same length');\r\n        }\r\n        if (idList) {\r\n            if (textList.length != idList.length) {\r\n                console.error({ 'not the same length': textList, 'as': idList });\r\n                throw new Error('textList and idList not the same length');\r\n            }\r\n            textList.forEach((text, ind) => {\r\n                this.newWrap('option', { id: idList[ind] }).text(text).setVal(valList![ind]);\r\n            })\r\n        } else {\r\n            textList.forEach((text, ind) => {\r\n                this.newWrap('option').text(text).setVal(valList![ind]);\r\n            })\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a flexbox-wrapped label & input pair\r\n     * @param inputTag input or textarea\r\n     * @param id the id to use for the input element\r\n     * @param location where the labeled input should be in relation to its caller\r\n     * @returns the Wrapper (for the outer div)\r\n     */\r\n    makeLabeledInput(id: string, inputTag?: 'input' | 'textarea', location?: WrapperPosition, options?: WrappedInputLabelPairOptions): WrappedInputLabelPair {\r\n        let container = this.newWrap('div', undefined, location)\r\n        inputTag = (inputTag === undefined) ? 'input' : inputTag;\r\n        location = (location === undefined) ? 'inside' : location;\r\n        let lbldInpt = new WrappedInputLabelPair(container.element, id, (<'input' | 'textarea'>inputTag), options);\r\n        return lbldInpt;\r\n    }\r\n}\r\n\r\nexport class WrapperlessObservable {\r\n    private value: string | number | boolean;\r\n    subscribers: WrapperlessObservableListMember[]\r\n    constructor(initVal: string | number | boolean) {\r\n        this.value = initVal;\r\n        this.subscribers = [];\r\n    }\r\n\r\n    /**\r\n     * Simple value getter\r\n     * @returns the observed value\r\n     */\r\n    getVal() {\r\n        return this.value;\r\n    }\r\n\r\n    /**\r\n     * Value setter, notifies subscribers of change\r\n     * @param newValue the new value for the observable\r\n     */\r\n    setVal(newValue: string | number | boolean) {\r\n        this.value = newValue;\r\n        this.notifySubscribers();\r\n    }\r\n\r\n    addSubscriber(newSub: WrapperlessObserver, xferFunc: Function) {\r\n        this.subscribers.push({ sub: newSub, xferFunc: xferFunc })\r\n    }\r\n\r\n    /**\r\n     * Propogate out a request to handle change to every entry in the subscriber list\r\n     * @returns this, for chaining\r\n     */\r\n    notifySubscribers() {\r\n        this.subscribers.forEach(m => {\r\n            m.sub.handleChange(this.value, m.xferFunc)\r\n        })\r\n    }\r\n}\r\n\r\nexport class Observer implements WrapperlessObserver {\r\n    value: string | number | boolean\r\n    constructor(init: string | number | boolean) {\r\n        this.value = init\r\n    }\r\n\r\n    /**\r\n        * Binds the Wrapper to a WrapperlessObservable instance. If you want to bind between\r\n        * wrappers, use the bindToWrapper method.\r\n        * @param target observerable to bind to\r\n        * @param boundFeature feature on this Wrapper to change, not used if xferFunc is supplied\r\n        * @param xferFunc optional, what to do with the new value, overrides boundFeature\r\n        * @returns this, for chaining\r\n        */\r\n    bindTo(target: WrapperlessObservable, xferFunc?: Function) {\r\n        if (xferFunc != undefined) {\r\n            target.addSubscriber(this, xferFunc);\r\n        } else {\r\n            target.addSubscriber(this, (nv: string | number | boolean) => { this.value = nv });\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Bind this wrapper's text/style/value to the text/style/value of the targetWrapper\r\n     * @param targetWrapper Wrapper to bind to\r\n     * @param targetFeature The feature you care about on the Wrapper you're subscribing \r\n     * @param thisFeature Which part of this Wrapper should be updated\r\n     * @param using optional transfer function, default: text for non-inputs, otherwise value\r\n     * @returns this, for chaining\r\n     */\r\n    bindToWrapper(targetWrapper: Wrapper, targetFeature: ObservableFeature, using?: Function): Observer {\r\n        if (using == undefined) using = (nv: string | number | boolean) => { return nv };\r\n        let sub: WrapperObservableListMember = {\r\n            toFeature: 'text',\r\n            bindFeature: targetFeature,\r\n            ofWrapper: targetWrapper, //hack - this isn't used in this context, but must exist\r\n            xferFunc: using\r\n        }\r\n        targetWrapper.addSubscriber(sub);\r\n        //initilize bound value to whatever it is now\r\n        let currentVal: string | number | boolean = targetWrapper.getText();\r\n        if (sub.bindFeature === 'style' && targetWrapper.getStyle() != null) currentVal = targetWrapper.getStyle()!;\r\n        if (sub.bindFeature === 'value') currentVal = targetWrapper.getVal();\r\n        this.handleChange(currentVal, using)\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Called by Observables when they are triggered by changes\r\n     * @param newVal the value to set\r\n     */\r\n    handleChange(newVal: string | number | boolean, doFun: Function) {\r\n        this.value = doFun(newVal);\r\n    }\r\n}\r\n\r\nexport class WrappedInputLabelPair extends Wrapper {\r\n    public container: HTMLElement;\r\n    public label: Wrapper;\r\n    public input: Wrapper;\r\n    constructor(container: HTMLElement, inputId: string, inputTag: \"input\" | \"textarea\" = 'input', options?: WrappedInputLabelPairOptions) {\r\n        super('div', container);\r\n        this.container = this.element;\r\n        this.style('display:flex');\r\n        this.label = this.newWrap('label').attr('for', inputId).text('Input');\r\n        this.input = this.newWrap(inputTag, { id: inputId });\r\n        if (options) {\r\n            if (options.contStyle) this.style(options.contStyle!);\r\n            if (options.inputStyle) this.input.style(options.inputStyle);\r\n            if (options.lblStyle) this.label.style(options.lblStyle);\r\n            if (options.lbl) this.label.text(options.lbl);\r\n            if (options.placehold) this.input.placehold(options.placehold);\r\n            if (options.default) this.input.setVal(options.default);\r\n            if (options.inputType) this.input.attr('type', options.inputType);\r\n            if (options.stacked && !options.contStyle && !options.inputStyle) {\r\n                this.style('display:block');\r\n                this.input.style('width: 100%; display: block')\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n//TODO - any other composites?","import './style.css'\nimport { Observer, Wrapper, WrapperlessObservable } from './wrapper'\n\nconst app = Wrapper.wrap(document.querySelector<HTMLDivElement>('#app')!);\napp.newWrap('h1',{text: 'Wrapper Library Test Page'});\n\n//#region #### Simple Examples ####\nlet simpleSection = app.newWrap('section',{html:'<h1>Simple Examples</h1>'}); \nlet myBody = simpleSection.newWrap('p',{id:'my-paragraph-2',style:'font-size:1.5em'})\n.text('Last time I checked, the time was: ' + new Date().toLocaleTimeString());\nsimpleSection.newWrap('button',{text: 'Check again'}).onEvent('click',()=>{\n  myBody.text(myBody.getText().substring(0, 35) + new Date().toLocaleTimeString()\n)});\n//#endregion\n\n//#region #### Composite Example ####\nlet compositeSection = app.newWrap('section').newWrap('h1',{text: \"Composite Examples\"}).newWrap('div',{style: 'display: grid; grid-column-layout: 1fr 1fr'},'after')\nlet features = ['Supports Chaining', 'Concise(er) syntax', 'Basic data binding', 'Component-ish things'];\ncompositeSection.newWrap('div',{style:\"grid-column-start:1\"}).newWrap('h2',{text: \"Create Lists from Arrays\"}).newWrap('ul',undefined,'after').listContent(features);\ncompositeSection.newWrap('div',{style:\"grid-column-start:2\"}).newWrap('h2',{text: \"Create Selects from Arrays\"}).newWrap('select',undefined,'after').selectContent(features);\n//#endregion\n\n//#region #### Labeled Input Examples ####\nlet lbldInptSection = app.newWrap('section',{html:'<h1>Label-Input Pairs</h1>'});\nlbldInptSection.newWrap('h2').text('Simple Text Input Example');\nlet inputPair = lbldInptSection.makeLabeledInput('text-input-example');\ninputPair.label.style('margin-right: 0.5em'); //accessing inner member of the inputPair\nlbldInptSection.newWrap('h2').text(\"Textarea Example\")\nlet textareaPair = lbldInptSection.makeLabeledInput('textarea-example','textarea','inside',{stacked:true});\ntextareaPair.label.style('margin-right: 0.5em');\nlbldInptSection.newWrap('h2').text(\"Other Types of Inputs\")\nlet grid = lbldInptSection.newWrap('div').style('display: grid; grid-template-columns: 1fr 1fr');\nlet checkPair = grid.makeLabeledInput('check-input','input','inside',{inputType:'checkbox', lbl: \"Show Date Example, too?\"});\n(<HTMLInputElement>checkPair.input.element).checked = true;\ncheckPair.input.onEvent('click',()=>{\n  if(checkPair.input.getVal()){\n    datePair.style('display:flex')\n  }else{\n    datePair.style('display:none')\n  }\n})\nlet datePair = grid.makeLabeledInput('date-input',undefined,undefined,{inputType:'date',lbl: \"Date Input\",lblStyle: \"margin-right: 0.5em\"});\n//#endregion\n\n//#region #### Binding to Variables ####\nlet genericBindingSection = app.newWrap('section',{html:\"<h1>Generic Data Binding</h1>\"});\ngenericBindingSection.newWrap('h2').text('Bound Wrapper to WrapperlessObservable')\nlet boundToVar = new WrapperlessObservable(5);\ngenericBindingSection.newWrap('p').text(boundToVar.getVal().toString()).bindTo(boundToVar,\"text\");\ngenericBindingSection.newWrap('button').text(\"Increment\").onClick(()=>{ boundToVar.setVal(<number>boundToVar.getVal()+1)});\ngenericBindingSection.newWrap('h2').text('Observer Watching the Observable From Above');\nlet boundVarView = genericBindingSection.newWrap('p').text('Double the number above: 10')\nnew Observer(boundToVar.getVal()).bindTo(boundToVar,(nv: number)=> {\n  boundVarView.text('Double the number above: ' + nv*2) //for illustration only\n  return nv*2\n});\ngenericBindingSection.newWrap('h2').text(\"Observer of Wrappers\");\nlet inputToBindAgainst = genericBindingSection.newWrap('input').placehold('Enter some text')\nlet wrapperBondVarView = genericBindingSection.newWrap('p').text(\"Input value: \");\nnew Observer('whatever').bindToWrapper(inputToBindAgainst,'value',(nv: string)=>{\n  wrapperBondVarView.text(\"Input value: \" + nv)\n  return nv;\n})\n//#endregion\n\n//#region #### Inter-Wrappter Data Binding Region ####\nlet wrapperBindingSection = app.newWrap('section',{html:\"<h1>Inter-Wrapper Binding Example</h1>\"});\nwrapperBindingSection.newWrap('h2').text('Bound Select, with Binding Breaker Demo')\nlet bindingSelect = wrapperBindingSection.newWrap('select').selectContent(['1', \"2\", \"3\"],[\"You picked one\", \"You picked two\", \"You picked three\"]);\nlet boundToSelect = wrapperBindingSection.newWrap('p').bindToWrapper(bindingSelect,'value','text');\nwrapperBindingSection.newWrap('button',{text:'Break Binding'}).onEvent('click',()=>{\n  bindingSelect.removeSubscriber(boundToSelect);\n  boundToSelect.text('Binding broken, this will no longer update.');\n}).style('margin-right: 0.5em')\nwrapperBindingSection.newWrap('button',{text: 'Re-bind'}).onEvent('click',()=>boundToSelect.bindToWrapper(bindingSelect,'value','text'));\nwrapperBindingSection.newWrap('h2',{text:\"Binding Text & Style (via xferFunc)\"})\nlet boundText = wrapperBindingSection.newWrap('p',{text: \"Enter some text below and watch me change...\"});\nlet bindingInput = wrapperBindingSection.newWrap('input').setVal('Enter a Color name!').placehold('Type a color name...');\nboundText.bindToWrapper(bindingInput,'value','text')\n  .bindToWrapper(bindingInput,'value','style',(newVal: string)=>{boundText.style('color:' + newVal)});\n//#endregion"],"names":[],"mappings":"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"}