{"version":3,"file":"WrapperLib.es.js","sources":["../src/wrapper.ts","../src/main.ts"],"sourcesContent":["/**\r\n * Options that Wrappers can be initialized with.\r\n */\r\nexport interface WrapperOptions {\r\n    id?: string;\r\n    name?: string;\r\n    value?: string;\r\n    text?: string;\r\n    html?: string;\r\n    style?: string;\r\n    bind?: WrapperObservableListMember;\r\n}\r\n\r\nexport interface WrapperObservableListMember {\r\n    bindFeature: ObservableFeature;\r\n    toFeature: ObservableFeature;\r\n    ofWrapper: Wrapper;\r\n    xferFunc?: Function;\r\n}\r\n\r\nexport interface WrapperlessObservableListMember {\r\n    xferFunc: Function;\r\n    sub: WrapperlessObserver;\r\n}\r\n\r\nexport interface WrapperlessObserver {\r\n    handleChange: Function;\r\n}\r\n\r\nexport interface WrappedInputLabelPairOptions {\r\n    lbl?: string,\r\n    default?: string,\r\n    placehold?: string,\r\n    inputType?: \"button\" | \"checkbox\" | \"color\" | \"date\" | \"datetime-local\" | \"email\" | \"file\" | \"hidden\" | \"image\" | \"month\" | \"number\" | \"password\" | \"radio\" | \"range\" | \"reset\" | \"search\" | \"submit\" | \"tel\" | \"text\" | \"time\" | \"url\" | \"week\",\r\n    contStyle?: string,\r\n    lblStyle?: string,\r\n    inputStyle?: string,\r\n    stacked?: boolean\r\n}\r\n\r\nexport type ObservableFeature = \"text\" | \"value\" | \"style\"\r\nexport type WrapperPosition = \"inside\" | \"before\" | \"after\"\r\n\r\ntype HTMLElementsWithValue = HTMLButtonElement | HTMLInputElement | HTMLMeterElement | HTMLLIElement | HTMLOptionElement | HTMLProgressElement | HTMLParamElement;\r\n\r\nexport class Wrapper {\r\n    public element: HTMLElement;\r\n    public subscribers: WrapperObservableListMember[];\r\n    constructor(tag?: keyof HTMLElementTagNameMap, existingElement?: HTMLElement, intializers?: WrapperOptions) {\r\n        this.subscribers = [];\r\n        if (existingElement) {\r\n            this.element = existingElement;\r\n        } else {\r\n            this.element = document.createElement(tag!)\r\n        }\r\n        //auto-call notify subscribers if inputs change\r\n        if (this.element.tagName === \"INPUT\") this.onEvent('input', this.notifySubscribers.bind(this));\r\n        if (this.element.tagName === \"SELECT\") this.onEvent('change', this.notifySubscribers.bind(this));\r\n        if (this.element.tagName === \"TEXTAREA\") this.onEvent('input', this.notifySubscribers.bind(this));\r\n        if (intializers) {\r\n            if (intializers.id) this.element.id = intializers.id!;\r\n            if (intializers.name) this.element.setAttribute('name', intializers.name!);\r\n            if (intializers.value) {\r\n                if (this.element.hasOwnProperty('value')) {\r\n                    (<HTMLElementsWithValue>this.element).value = intializers.value!;\r\n                } else {\r\n                    throw new Error(\"attempted to set value on a tag that doesn't support that\")\r\n                }\r\n            }\r\n            if (intializers.text != undefined) this.element.innerText = intializers.text!;\r\n            if (intializers.html != undefined) this.element.innerHTML = intializers.html!;\r\n            if (intializers.style) this.element.setAttribute('style', intializers.style!);\r\n            if (intializers.bind) {\r\n                let sub: WrapperObservableListMember = {\r\n                    bindFeature: intializers.bind.bindFeature,\r\n                    toFeature: intializers.bind.toFeature,\r\n                    ofWrapper: this,\r\n                    xferFunc: intializers.bind.xferFunc\r\n                }\r\n                intializers.bind.ofWrapper.addSubscriber(sub);//this feels wrong\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Wraps an existing HTML Element with a Wrapper\r\n     * @param element the element to wrap\r\n     * @returns the new wrapper, for chaining\r\n     */\r\n    static wrap(element: HTMLElement, initializers?: WrapperOptions): Wrapper {\r\n        return new Wrapper((<keyof HTMLElementTagNameMap>element.tagName), element, initializers);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Wrapper instance inside, before, or after the one it was called against.\r\n     * Returns the newly created wrapper.\r\n     * @param tag tag of the HTML Element to create\r\n     * @param initializers an object with optional keys to initialize the element with\r\n     * @param locaitn inside appendChild(), before before(), after after()\r\n     * @returns the new wrapper, for chaining\r\n     */\r\n    newWrap(tag: keyof HTMLElementTagNameMap, initializers?: WrapperOptions, location: WrapperPosition = 'inside'): Wrapper {\r\n        let nW = new Wrapper(tag, undefined, initializers);\r\n        if (location === 'inside') this.element.appendChild(nW.element);\r\n        if (location === 'after') this.element.after(nW.element);\r\n        if (location === 'before') this.element.before(nW.element);\r\n        return nW;\r\n    }\r\n\r\n    /**\r\n     * Binds the Wrapper to a WrapperlessObservable instance. If you want to bind between\r\n     * wrappers, use the bindToWrapper method.\r\n     * @param target observerable to bind to\r\n     * @param boundFeature feature on this Wrapper to change, not used if xferFunc is supplied\r\n     * @param xferFunc optional, what to do with the new value, overrides boundFeature\r\n     */\r\n    bindTo(target: WrapperlessObservable, boundFeature?: ObservableFeature, xferFunc?: Function) {\r\n        if (xferFunc != undefined) {\r\n            target.addSubscriber(this, xferFunc);\r\n        } else {\r\n            if (boundFeature == undefined) throw new Error(\"No bound feature or xferFunc included.\");\r\n            if (boundFeature == 'text') target.addSubscriber(this, (nv: string) => this.text(nv));\r\n            if (boundFeature == 'value') target.addSubscriber(this, (nv: string) => this.setVal(nv));\r\n            if (boundFeature == 'style') target.addSubscriber(this, (nv: string) => this.style(nv));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Bind this wrapper's text/style/value to the text/style/value of the targetWrapper\r\n     * @param targetWrapper Wrapper to bind to\r\n     * @param targetFeature The feature you care about on the Wrapper you're subscribing \r\n     * @param thisFeature Which part of this Wrapper should be updated\r\n     * @param using optional transfer function, default: text for non-inputs, otherwise value\r\n     * @returns this, for chaining\r\n     */\r\n    bindToWrapper(targetWrapper: Wrapper, targetFeature: ObservableFeature, thisFeature: ObservableFeature, using?: Function): Wrapper {\r\n        let sub: WrapperObservableListMember = {\r\n            bindFeature: targetFeature,\r\n            toFeature: thisFeature,\r\n            ofWrapper: this,\r\n            xferFunc: using\r\n        }\r\n        targetWrapper.addSubscriber(sub);\r\n        //initilize bound value to whatever it is now\r\n        let currentVal = targetWrapper.getText();\r\n        if (sub.bindFeature === 'style' && targetWrapper.getStyle() != null) currentVal = targetWrapper.getStyle()!;\r\n        if (sub.bindFeature === 'value') currentVal = targetWrapper.getVal().toString();\r\n        this.handleChange(currentVal, sub)\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Propogate out a request to handle change to every entry in the subscriber list\r\n     * @returns this, for chaining\r\n     */\r\n    notifySubscribers(): Wrapper {\r\n        // console.warn\r\n        this.subscribers.forEach(sub => {\r\n            let newVal = this.getText();\r\n            if (sub.bindFeature == 'value') newVal = this.getVal().toString();\r\n            if (sub.bindFeature == 'style') newVal = this.getStyle()!;\r\n            sub.ofWrapper.handleChange(newVal, sub)\r\n        })\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates this wrapper with the new value from the WrapperObservable that called it,\r\n     * in accordance with the terms of the subscription.\r\n     * @param newValue the new value from the thing\r\n     * @param subscription the subscription itself, or the function to run\r\n     */\r\n    handleChange(newValue: string, subscription: WrapperObservableListMember | Function): void {\r\n        if (typeof subscription === 'function') {\r\n            subscription(newValue);\r\n        } else {\r\n            if (subscription.xferFunc) {\r\n                subscription.xferFunc(newValue);\r\n            } else {\r\n                if (subscription.toFeature === 'text') this.text(newValue);\r\n                if (subscription.toFeature === 'style') this.style(newValue);\r\n                if (subscription.toFeature === 'value') this.setVal(newValue);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a new subscriber, which contains a subscribing wrapper and\r\n     * details about how it should be updated on changes to this.\r\n     * @param newSub subscribing wrapper to add\r\n     * @returns this, for chaining\r\n     */\r\n    addSubscriber(newSub: WrapperObservableListMember): Wrapper {\r\n        this.subscribers.push(newSub);\r\n        return this;\r\n    }\r\n\r\n    //removeSubscriber //todo - this\r\n    removeSubscriber(subbedWrapper: Wrapper): Wrapper {\r\n        this.subscribers = this.subscribers.filter(sub => sub.ofWrapper != subbedWrapper)\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes all subscribers from the list.\r\n     * @returns this, for chaining\r\n     */\r\n    purgeSubscribers() {\r\n        this.subscribers = [];\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Sets the innerText of the wrapped element.\r\n     * @param text the text to set\r\n     * @returns this, for chaining\r\n     */\r\n    text(text: string): Wrapper {\r\n        this.element.innerText = text;\r\n        this.subscribers.forEach(sub => { if (sub.bindFeature == 'text') sub.ofWrapper.handleChange(text, sub) });\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Chainable horthand for this.element.setAttribute(attribute, value)\r\n     * @param attribute attribute to set\r\n     * @param value value to set it to\r\n     * @returns this, for chaining\r\n     */\r\n    attr(attribute: string, value: string): Wrapper {\r\n        this.element.setAttribute(attribute, value)\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the innerHTML of the wrapped element.\r\n     * @param html the text to set\r\n     * @returns this, for chaining\r\n     */\r\n    html(html: string): Wrapper {\r\n        this.element.innerHTML = html;\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Sets the `style` attribute of the wrapped element\r\n     * @param styleString string literal for css styles\r\n     * @param append true = append to the existing styles; false =  replace it\r\n     * @returns this, for chaining\r\n     */\r\n    style(styleString: string, append?: boolean): Wrapper {\r\n        let style = \"\";\r\n        if (append && this.element.getAttribute('style') != null) {\r\n            style = this.element.getAttribute('style')!.trim();\r\n            if (style.charAt(style.length - 1) != \";\") style = style + \"; \"\r\n        }\r\n        this.element.setAttribute('style', style + styleString);\r\n        this.subscribers.forEach(sub => { if (sub.bindFeature === 'style') sub.ofWrapper.handleChange(styleString, sub) });\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Sets the name of the wrapped element.\r\n     * @param name the text to set\r\n     * @returns this, for chaining\r\n     */\r\n    name(name: string): Wrapper {\r\n        this.element.setAttribute('name', name);\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Sets the placeholder of the wrapped element.\r\n     * @param placeholder the text to set\r\n     * @returns this, for chaining\r\n     */\r\n    placehold(placeholder: string): Wrapper {\r\n        this.element.setAttribute('placeholder', placeholder);\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Returns the value of a given attribute on the wrapped element\r\n     * @returns the value of attribute on the element, or null if no attribute exists\r\n     */\r\n    getAttr(attribute: string): string | null {\r\n        return this.element.getAttribute(attribute);\r\n    }\r\n\r\n    /**\r\n     * Simple alias for {@link attr}.\r\n     * @param attribute attribute name to set\r\n     * @param value the value to set\r\n     * @returns this, for chaining\r\n     */\r\n    setAttr(attribute: string, value: string): Wrapper {\r\n        return this.attr(attribute, value);\r\n    }\r\n\r\n    /**\r\n     * Returns the style string of a given attribute on the wrapped element\r\n     * @returns the style string of attribute on the element, or null if no attribute exists\r\n     */\r\n    getStyle(): string | null {\r\n        return this.element.getAttribute('style');\r\n    }\r\n\r\n    /**\r\n     * Simple alias for {@link style}.\r\n     * @param styleString the value to set\r\n     * @returns this, for chaining\r\n     */\r\n    setStyle(styleString: string): Wrapper {\r\n        return this.style(styleString);\r\n    }\r\n\r\n    /**\r\n     * Returns the innerText of the wrapped element\r\n     * @returns the innerText of the wrapped element\r\n     */\r\n    getText(): string {\r\n        return this.element.innerText;\r\n    }\r\n\r\n    /**\r\n     * Simple alias for {@link text}.\r\n     * @param text string to set\r\n     * @returns this, for chaining\r\n     */\r\n    setText(text: string): Wrapper {\r\n        return this.text(text);\r\n    }\r\n\r\n\r\n    /**\r\n     * Gets the value of Wrapped things like inputs, textareas\r\n     * @returns the value of the wrapped element\r\n     */\r\n    getVal() {\r\n        if (this.element.tagName == 'INPUT' && this.getAttr('type') == \"checkbox\") return (<HTMLInputElement>this.element).checked;\r\n        return (<HTMLInputElement>this.element).value //inline type assertion IS possible\r\n    }\r\n\r\n    /**\r\n     * Sets the value of Wrapped things like inputs, textareas\r\n     * @returns this, for chaining\r\n     */\r\n    setVal(val: string) {\r\n        (<HTMLInputElement | HTMLParamElement | HTMLButtonElement |\r\n            HTMLOptionElement | HTMLLIElement>this.element).value = val;\r\n        this.subscribers.forEach(sub => { if (sub.bindFeature === \"value\") sub.ofWrapper.handleChange(val, sub) });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Grabs data stored in an element's dataset. The 'data-' part\r\n     * of the dataset is not necessary to include.\r\n     * @param key the data- set element name\r\n     * @returns the value of the keyed data\r\n     */\r\n    getData(key: string) {\r\n        return this.element.dataset[key];\r\n    }\r\n\r\n    /**\r\n     * Sets data stored in an element's dataset. The 'data-' part\r\n     * of the dataset is not necessary to include.\r\n     * @param key the data- set element name\r\n     * @param val the string to be stored\r\n     * @returns this, for chaining\r\n     */\r\n    setData(key: string, val: string) {\r\n        this.element.setAttribute('data-' + key, val);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new event listener of the given type on the Wrapped element\r\n     * @param eventType type of event to bind the function to\r\n     * @param fun the function to run when the event occurs\r\n     * @returns this, for chaining\r\n     */\r\n    onEvent(eventType: keyof HTMLElementEventMap, fun: Function): Wrapper {\r\n        this.element.addEventListener(eventType, (e) => fun(e));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new click event listener on the wrapped element\r\n     * @param fun the function to run on click;\r\n     * @returns this, for chaining\r\n     */\r\n    onClick(fun: Function): Wrapper {\r\n        this.onEvent('click', fun);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n    * Creates a new input event listener on the wrapped element\r\n    * @param fun the function to run on input;\r\n    * @returns this, for chaining\r\n    */\r\n    onInput(fun: Function): Wrapper {\r\n        this.onEvent('input', fun);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new change event listener on the wrapped element\r\n     * @param fun the function to run on changes;\r\n     * @returns this, for chaining\r\n     */\r\n    onChange(fun: Function): Wrapper {\r\n        this.onEvent('change', fun);\r\n        return this;\r\n    }\r\n\r\n    ///#region #### Composite Wrappers ####\r\n\r\n    /**\r\n     * For use with <ol> or <ul> elements\r\n     * Creates a series of <li> elements for elements in an array\r\n     * @param textList the visible text to create each element for\r\n     * @param idList optional IDs to include\r\n     * @returns this, for chaining\r\n     */\r\n    listContent(textList: string[], idList?: string[]) {\r\n        if (this.element.tagName != 'UL' && this.element.tagName != 'OL') {\r\n            console.error({ 'Not a list container->:': this.element });\r\n            throw new Error('List Content must be appended to a \"ul\" or \"ol\"');\r\n        }\r\n        if (idList) {\r\n            if (textList.length != idList.length) {\r\n                console.error({ 'not the same length': textList, 'as': idList });\r\n                throw new Error('textList and idList not the same length');\r\n            }\r\n            textList.forEach((text, ind) => {\r\n                this.newWrap('li', { 'id': idList[ind] }).text(text);\r\n            })\r\n        } else {\r\n            textList.forEach((text) => {\r\n                this.newWrap('li').text(text);\r\n            })\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * For use with <select> elements\r\n     * Creates a list of <option> elements inside the <select>\r\n     * with the given display text and value text\r\n     * @param textList \r\n     * @param valList \r\n     * @param idList \r\n     * @returns this, for chaining\r\n     */\r\n    selectContent(textList: string[], valList?: string[], idList?: string[]) {\r\n        if (!valList) valList = textList;\r\n        if (textList.length != valList.length) {\r\n            console.error({ 'not the same length': textList, 'as': valList });\r\n            throw new Error('textList and idList not the same length');\r\n        }\r\n        if (idList) {\r\n            if (textList.length != idList.length) {\r\n                console.error({ 'not the same length': textList, 'as': idList });\r\n                throw new Error('textList and idList not the same length');\r\n            }\r\n            textList.forEach((text, ind) => {\r\n                this.newWrap('option', { id: idList[ind] }).text(text).setVal(valList![ind]);\r\n            })\r\n        } else {\r\n            textList.forEach((text, ind) => {\r\n                this.newWrap('option').text(text).setVal(valList![ind]);\r\n            })\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a flexbox-wrapped label & input pair\r\n     * @param inputTag input or textarea\r\n     * @param id the id to use for the input element\r\n     * @param location where the labeled input should be in relation to its caller\r\n     * @returns the Wrapper (for the outer div)\r\n     */\r\n    makeLabeledInput(id: string, inputTag?: 'input' | 'textarea', location?: WrapperPosition, options?: WrappedInputLabelPairOptions): WrappedInputLabelPair {\r\n        let container = this.newWrap('div', undefined, location)\r\n        inputTag = (inputTag === undefined) ? 'input' : inputTag;\r\n        location = (location === undefined) ? 'inside' : location;\r\n        let lbldInpt = new WrappedInputLabelPair(container.element, id, (<'input' | 'textarea'>inputTag), options);\r\n        return lbldInpt;\r\n    }\r\n}\r\n\r\nexport class WrapperlessObservable {\r\n    private value: string | number | boolean;\r\n    subscribers: WrapperlessObservableListMember[]\r\n    constructor(initVal: string | number | boolean) {\r\n        this.value = initVal;\r\n        this.subscribers = [];\r\n    }\r\n\r\n    /**\r\n     * Simple value getter\r\n     * @returns the observed value\r\n     */\r\n    getVal() {\r\n        return this.value;\r\n    }\r\n\r\n    /**\r\n     * Value setter, notifies subscribers of change\r\n     * @param newValue the new value for the observable\r\n     */\r\n    setVal(newValue: string | number | boolean) {\r\n        this.value = newValue;\r\n        this.notifySubscribers();\r\n    }\r\n\r\n    addSubscriber(newSub: WrapperlessObserver, xferFunc: Function) {\r\n        this.subscribers.push({ sub: newSub, xferFunc: xferFunc })\r\n    }\r\n\r\n    /**\r\n     * Propogate out a request to handle change to every entry in the subscriber list\r\n     * @returns this, for chaining\r\n     */\r\n    notifySubscribers() {\r\n        this.subscribers.forEach(m => {\r\n            m.sub.handleChange(this.value, m.xferFunc)\r\n        })\r\n    }\r\n}\r\n\r\nexport class Observer implements WrapperlessObserver {\r\n    value: string | number | boolean\r\n    constructor(init: string | number | boolean) {\r\n        this.value = init\r\n    }\r\n\r\n    /**\r\n        * Binds the Wrapper to a WrapperlessObservable instance. If you want to bind between\r\n        * wrappers, use the bindToWrapper method.\r\n        * @param target observerable to bind to\r\n        * @param boundFeature feature on this Wrapper to change, not used if xferFunc is supplied\r\n        * @param xferFunc optional, what to do with the new value, overrides boundFeature\r\n        * @returns this, for chaining\r\n        */\r\n    bindTo(target: WrapperlessObservable, xferFunc?: Function) {\r\n        if (xferFunc != undefined) {\r\n            target.addSubscriber(this, xferFunc);\r\n        } else {\r\n            target.addSubscriber(this, (nv: string | number | boolean) => { this.value = nv });\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Bind this wrapper's text/style/value to the text/style/value of the targetWrapper\r\n     * @param targetWrapper Wrapper to bind to\r\n     * @param targetFeature The feature you care about on the Wrapper you're subscribing \r\n     * @param thisFeature Which part of this Wrapper should be updated\r\n     * @param using optional transfer function, default: text for non-inputs, otherwise value\r\n     * @returns this, for chaining\r\n     */\r\n    bindToWrapper(targetWrapper: Wrapper, targetFeature: ObservableFeature, using?: Function): Observer {\r\n        if (using == undefined) using = (nv: string | number | boolean) => { return nv };\r\n        let sub: WrapperObservableListMember = {\r\n            toFeature: 'text',\r\n            bindFeature: targetFeature,\r\n            ofWrapper: targetWrapper, //hack - this isn't used in this context, but must exist\r\n            xferFunc: using\r\n        }\r\n        targetWrapper.addSubscriber(sub);\r\n        //initilize bound value to whatever it is now\r\n        let currentVal: string | number | boolean = targetWrapper.getText();\r\n        if (sub.bindFeature === 'style' && targetWrapper.getStyle() != null) currentVal = targetWrapper.getStyle()!;\r\n        if (sub.bindFeature === 'value') currentVal = targetWrapper.getVal();\r\n        this.handleChange(currentVal, using)\r\n        return this\r\n    }\r\n\r\n    /**\r\n     * Called by Observables when they are triggered by changes\r\n     * @param newVal the value to set\r\n     */\r\n    handleChange(newVal: string | number | boolean, doFun: Function) {\r\n        this.value = doFun(newVal);\r\n    }\r\n}\r\n\r\nexport class WrappedInputLabelPair extends Wrapper {\r\n    public container: HTMLElement;\r\n    public label: Wrapper;\r\n    public input: Wrapper;\r\n    constructor(container: HTMLElement, inputId: string, inputTag: \"input\" | \"textarea\" = 'input', options?: WrappedInputLabelPairOptions) {\r\n        super('div', container);\r\n        this.container = this.element;\r\n        this.style('display:flex');\r\n        this.label = this.newWrap('label').attr('for', inputId).text('Input');\r\n        this.input = this.newWrap(inputTag, { id: inputId });\r\n        if (options) {\r\n            if (options.contStyle) this.style(options.contStyle!);\r\n            if (options.inputStyle) this.input.style(options.inputStyle);\r\n            if (options.lblStyle) this.label.style(options.lblStyle);\r\n            if (options.lbl) this.label.text(options.lbl);\r\n            if (options.placehold) this.input.placehold(options.placehold);\r\n            if (options.default) this.input.setVal(options.default);\r\n            if (options.inputType) this.input.attr('type', options.inputType);\r\n            if (options.stacked && !options.contStyle && !options.inputStyle) {\r\n                this.style('display:block');\r\n                this.input.style('width: 100%; display: block')\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n//TODO - any other composites?","import './style.css'\nimport { Observer, Wrapper, WrapperlessObservable } from './wrapper'\n\nconst app = Wrapper.wrap(document.querySelector<HTMLDivElement>('#app')!);\napp.newWrap('h1',{text: 'Wrapper Library Test Page'});\n\n//#region #### Simple Examples ####\nlet simpleSection = app.newWrap('section',{html:'<h1>Simple Examples</h1>'}); \nlet myBody = simpleSection.newWrap('p',{id:'my-paragraph-2',style:'font-size:1.5em'})\n.text('Last time I checked, the time was: ' + new Date().toLocaleTimeString());\nsimpleSection.newWrap('button',{text: 'Check again'}).onEvent('click',()=>{\n  myBody.text(myBody.getText().substring(0, 35) + new Date().toLocaleTimeString()\n)});\n//#endregion\n\n//#region #### Composite Example ####\nlet compositeSection = app.newWrap('section').newWrap('h1',{text: \"Composite Examples\"}).newWrap('div',{style: 'display: grid; grid-column-layout: 1fr 1fr'},'after')\nlet features = ['Supports Chaining', 'Concise(er) syntax', 'Basic data binding', 'Component-ish things'];\ncompositeSection.newWrap('div',{style:\"grid-column-start:1\"}).newWrap('h2',{text: \"Create Lists from Arrays\"}).newWrap('ul',undefined,'after').listContent(features);\ncompositeSection.newWrap('div',{style:\"grid-column-start:2\"}).newWrap('h2',{text: \"Create Selects from Arrays\"}).newWrap('select',undefined,'after').selectContent(features);\n//#endregion\n\n//#region #### Labeled Input Examples ####\nlet lbldInptSection = app.newWrap('section',{html:'<h1>Label-Input Pairs</h1>'});\nlbldInptSection.newWrap('h2').text('Simple Text Input Example');\nlet inputPair = lbldInptSection.makeLabeledInput('text-input-example');\ninputPair.label.style('margin-right: 0.5em'); //accessing inner member of the inputPair\nlbldInptSection.newWrap('h2').text(\"Textarea Example\")\nlet textareaPair = lbldInptSection.makeLabeledInput('textarea-example','textarea','inside',{stacked:true});\ntextareaPair.label.style('margin-right: 0.5em');\nlbldInptSection.newWrap('h2').text(\"Other Types of Inputs\")\nlet grid = lbldInptSection.newWrap('div').style('display: grid; grid-template-columns: 1fr 1fr');\nlet checkPair = grid.makeLabeledInput('check-input','input','inside',{inputType:'checkbox', lbl: \"Show Date Example, too?\"});\n(<HTMLInputElement>checkPair.input.element).checked = true;\ncheckPair.input.onEvent('click',()=>{\n  if(checkPair.input.getVal()){\n    datePair.style('display:flex')\n  }else{\n    datePair.style('display:none')\n  }\n})\nlet datePair = grid.makeLabeledInput('date-input',undefined,undefined,{inputType:'date',lbl: \"Date Input\",lblStyle: \"margin-right: 0.5em\"});\n//#endregion\n\n//#region #### Binding to Variables ####\nlet genericBindingSection = app.newWrap('section',{html:\"<h1>Generic Data Binding</h1>\"});\ngenericBindingSection.newWrap('h2').text('Bound Wrapper to WrapperlessObservable')\nlet boundToVar = new WrapperlessObservable(5);\ngenericBindingSection.newWrap('p').text(boundToVar.getVal().toString()).bindTo(boundToVar,\"text\");\ngenericBindingSection.newWrap('button').text(\"Increment\").onClick(()=>{ boundToVar.setVal(<number>boundToVar.getVal()+1)});\ngenericBindingSection.newWrap('h2').text('Observer Watching the Observable From Above');\nlet boundVarView = genericBindingSection.newWrap('p').text('Double the number above: 10')\nnew Observer(boundToVar.getVal()).bindTo(boundToVar,(nv: number)=> {\n  boundVarView.text('Double the number above: ' + nv*2) //for illustration only\n  return nv*2\n});\ngenericBindingSection.newWrap('h2').text(\"Observer of Wrappers\");\nlet inputToBindAgainst = genericBindingSection.newWrap('input').placehold('Enter some text')\nlet wrapperBondVarView = genericBindingSection.newWrap('p').text(\"Input value: \");\nnew Observer('whatever').bindToWrapper(inputToBindAgainst,'value',(nv: string)=>{\n  wrapperBondVarView.text(\"Input value: \" + nv)\n  return nv;\n})\n//#endregion\n\n//#region #### Inter-Wrappter Data Binding Region ####\nlet wrapperBindingSection = app.newWrap('section',{html:\"<h1>Inter-Wrapper Binding Example</h1>\"});\nwrapperBindingSection.newWrap('h2').text('Bound Select, with Binding Breaker Demo')\nlet bindingSelect = wrapperBindingSection.newWrap('select').selectContent(['1', \"2\", \"3\"],[\"You picked one\", \"You picked two\", \"You picked three\"]);\nlet boundToSelect = wrapperBindingSection.newWrap('p').bindToWrapper(bindingSelect,'value','text');\nwrapperBindingSection.newWrap('button',{text:'Break Binding'}).onEvent('click',()=>{\n  bindingSelect.removeSubscriber(boundToSelect);\n  boundToSelect.text('Binding broken, this will no longer update.');\n}).style('margin-right: 0.5em')\nwrapperBindingSection.newWrap('button',{text: 'Re-bind'}).onEvent('click',()=>boundToSelect.bindToWrapper(bindingSelect,'value','text'));\nwrapperBindingSection.newWrap('h2',{text:\"Binding Text & Style (via xferFunc)\"})\nlet boundText = wrapperBindingSection.newWrap('p',{text: \"Enter some text below and watch me change...\"});\nlet bindingInput = wrapperBindingSection.newWrap('input').setVal('Enter a Color name!').placehold('Type a color name...');\nboundText.bindToWrapper(bindingInput,'value','text')\n  .bindToWrapper(bindingInput,'value','style',(newVal: string)=>{boundText.style('color:' + newVal)});\n//#endregion"],"names":[],"mappings":"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"}